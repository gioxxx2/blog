---
title: ARM64汇编入门与应用
date: 2019-02-01 10:47:23
categories: iOS
tags:
    - 汇编
    - ARM64
---

本文主要整理ARM64汇编基础知识，因为之前做逆向开发和调试系统栈的时候，都需要汇编相关的知识，做此整理，以供后续查阅。掌握汇编对于突破iOS开发水平的瓶颈十分有效。

<!--more-->

## 逆向中的反调试

**ptrace**

为了方便应用软件的开发和调试，从Unix的早期版本开始就提供了一种对运行中的进程进行跟踪和控制的手段，那就是系统调用ptrace()。
通过ptrace可以对另一个进程实现调试跟踪，同时ptrace还提供了一个非常有用的参数那就是PT_DENY_ATTACH，这个参数用来告诉系统，阻止调试器依附。

所以最常用的反调试方案就是通过调用ptrace来实现反调试。

```
ptrace(31, 0, 0, 0)
```
这种方式能够被函数hook轻易破解，例如使用facebook的[fishhook](https://github.com/facebook/fishhook)。 为了防止函数被hook，我们可以将函数调用转为通过汇编发起系统调用，即使用下面的代码。

```
mov x0, #31
mov x1, #0
mov x2, #0
mov x3, #0
mov x16, #26
svc #0x80
```
其中x0-x3存储的为函数入参，x16存储的为函数编号，通过Apple提供的[System Call Table](https://www.theiphonewiki.com/wiki/Kernel_Syscalls) 可以查出ptrace的编号为26，最后一句指令发起了系统调用。 通过使用__asm__指令能够将汇编代码嵌入我们的函数中，构成反调试方法。

```
// 使用inline方式将函数在调用处强制展开，防止被hook和追踪符号
static __attribute__((always_inline)) void anti_debug() {
// 判断是否是ARM64处理器指令集
#ifdef __arm64__
    // volatile修饰符能够防止汇编指令被编译器忽略
    __asm__ __volatile__(
                         "mov x0, #31\n"
                         "mov x1, #0\n"
                         "mov x2, #0\n"
                         "mov x3, #0\n"
                         "mov x16, #26\n"
                         "svc #0x80\n"
                         );
#endif
}
```
虽然上面的反调试机制并不完善，但是比直接调用ptrace要好上很多倍，从这一点来看，掌握汇编技能对于iOS应用安全和底层研究非常有利。

## ARM64入门

汇编的所有指令操作都是围绕栈实现的，在汇编中，没有变量的概念，只有寄存器和内存。

### ARM64寄存器

r0 - r30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 x0 - x30访问时，它就是一个64位的数。当使用 w0 - w30访问时，访问的是这些寄存器的低32位。

其实通用寄存器有32个，第32个寄存器x31，在指令编码中，使用来做 zero register, 即ZR, XZR/WZR分别代表64/32位，zero register的作用就是0，写进去代表丢弃结果，拿出来是0。

* 通用寄存器
    * 64bit: x0 - x28
    * 32bit: w0 - w28
    *  x0 – x7 分别会存放方法的前 8 个参数，如果参数个数超过了8个，多余的参数会存在栈上，新方法会通过栈来读取。
    *  方法的返回值一般都在 x0 上。
    *  如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。

* 程序计数器
    * pc（Program Counter）寄存器中存的是当前执行的指令的地址, 记录CPU当前指令是哪一条指令。

* 堆栈指针（栈是从高地址到低地址的）
    * sp（Stack Pointer）指向栈顶，也就是低地址。
    * fp（Frame Pointer）指向当前frame的栈底，也就是高地址。也是x29。

* 链接寄存器
    * lr（Link Register）存储函数返回地址。也就是x30。

* 状态寄存器
    * 在汇编中就需要根据状态寄存器中的一些状态来控制分支的执行。
    * cpsr（Current Program Status Register）
    * spsr（Saved Program Status Register）一般都是使用CPSR， 当发生异常时， CPSR会存入SPSR。当异常恢复，再拷贝回CPSR。




### ARM64常用指令

查询某个指令如何使用，最好的方式是去查询ARM公司提供的[官方文档](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/STUR_fpsimd.html)，本文会简单介绍一些常用指令。

#### LDR指令：从内存读数据
load register，从存储器将一个32位的字数据传送到目的寄存器。
指令格式与实例：

```
LDR{条件} 目的寄存器，存储器地址   <<<<
LDR R0,[R1,#8] ; 将存储器地址为R1+8的字数据读入寄存器R0
```
#### STR指令：往内存写数据
store register，从源寄存器将一个32位字数据传送到存储器中。
指令格式与实例：

```
STR{条件} 源寄存器，存储器地址    >>>>
STR R0,[R1,#8]  ; 将R0中的数据写入以R1+8为地址的存储器中
```
#### 指令条件域

当处理器工作在ARM状态时，几乎所有指令都根据CPSR中的条件码的状态和指令的条件域有条件的执行。当指令的执行条件满足时，指令执行，否则被忽略。

如：跳转指令B加载EQ后缀变为BEQ表示相等则跳转，即当CPSR中的Z标志置位时发生跳转。

![屏幕快照 2019-02-01 下午7.16.01](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.16.01.png)

* b:跳转指令，可以带条件跳转，一般配合cmp使用
* bl:带返回的跳转指令，执行的操作
    * 将下一条指令的地址存储到lr寄存器中
    * 跳转到标记处开始执行代码
* ret:函数返回，将lr(x30)寄存器的值赋值给pc
* cmp指令格式：

```
cmp r1,r0 ; 将寄存器r1的值与寄存器r0的值相减，并根据结果设置CPSR的标志位
```
* mov指令格式：

```
mov{条件}{s} 目的寄存器，源操作数 ；s选项决定指令的操作是否影响cpsr中条件标志位的值，没有s则不更新cpsr条件标志位的值
mov r1,r0 ; r0的值给r1  <<<<
add r0,r1,r2 ; r0 = r1 + r2
sub r0,r1,r2 ; r0 = r1 + r2
```
### 寻址方式

* 立即数寻址: 操作数本身就在指令中给出

```
ADD R0,R0,#1 ; R0<-R0+1
ADD R0,R0,#0x3f ; R0<-R0+0x3f
```
* 寄存器寻址: 利用寄存器中的数值作为操作数

```
ADD R0,R1,R2  ; R0<-R1+R2
```
* 寄存器间接寻址: 以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。

```
LDR R0,[R1]  ; R0<-[R1] 将以R1的值为地址的存储器中的数据传送到R0
STR R0,[R1]  ; R0->[R1] 将R0的值传送到以R1的值为地址的存储器中
```
* 基址变址寻址: 将寄存器的内容与指令给出的地址偏移量相加，从而得到一个操作数的有效地址，常用于访问某基址附近的地址单元。

```
LDR R0,[R1,#4] ; R0<-[R1+4] 将寄存器R1的内容加上4形成操作数的有效地址，再取得操作数存入寄存器R0中
```
* 相对寻址：与基址变址寻址类似，相对寻址以PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加后得到操作数的有效地址。BL采用了相对寻址。

```
    BL NEXT  ; 跳转到子程序NEXT处执行
    ...
NEXT
    ...
    MOV PC，LR ； 从子程序返回
```
### 栈

汇编中的栈是由高地址向低地址生长的数据结构，sp指针永远指向栈顶。需要记住的是，在某位置进行存储时，是对高地址进行的。

![屏幕快照 2019-02-01 上午11.24.17](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.24.17.png)

使用clang可以将其编译为特定指令集的汇编代码，这里我们将其编译为ARM64指令集的汇编代码。

```
clang -S -arch arm64 -isysroot `xcrun --sdk iphoneos --show-sdk-path` main.c
```
我们只看对test函数的调用，节选这一段汇编代码。
![F2E5ED94-9E1C-43F1-ABF7-6152D3C826E5](/images/F2E5ED94-9E1C-43F1-ABF7-6152D3C826E5.png)


test函数涉及了3个int变量，分别是a、b、res，int变量占据4个字节，因此一共需要12个字节，但ARM64汇编为了提高访问效率要求按照16字节进行对齐，因此需要16byte的空间，也就是需要在栈上开辟16字节的空间，我们来看汇编的第一句，正是将sp指针下移16字节。

```
sub	sp, sp, #16
```
![屏幕快照 2019-02-01 下午7.50.54](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.50.54.png)

sp下移16后，留下了4个4字节的内存空格，共计16字节，我们继续看下面的句子。

```
str	w0, [sp, #12]
str	w1, [sp, #8]
```
这两句的含义是将w0存储在sp+12的格子中，w1存储在sp+8的格子中，上面的例子中提到x0, x1等寄存器将顺序存放函数的入参，x0和w0是同一个寄存器的不同尺寸提现，x0为8字节，w0为x0的前4个字节，因此w0是函数的第一个入参a，w1是函数的第二个入参b，由于存储是从低地址到高地址的，所以a将占据sp+12~sp+16，同理b将占据sp+8~sp+12，则栈的结构变为下图。

![屏幕快照 2019-02-01 下午7.53.21](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.53.21.png)

接下来test函数应该将a和b相加，需要注意的是，只有寄存器才能参与运算，因此接下来的汇编代码又将变量的值从内存中读出，进行相加运算。

```
	ldr	w0, [sp, #12]
	ldr	w1, [sp, #8]
	add w0, w0, w1
```
由此可见先存储再读取后运算其实是多余的，这是没有进行编译优化的结果，学习不进行编译优化的汇编更能让我们理解其工作机制。

接下来的代码将w0存入了sp+4，也就是res变量的内存区域。

```
str	w0, [sp, #4]
```
![屏幕快照 2019-02-01 下午7.55.23](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.55.23.png)

接下来就要进行返回了，在例子中我们提到，函数的返回值一般存储在x0寄存器中返回，因此我们需要将res的值载入x0寄存器。

```
ldr	w0, [sp, #4]
```
这里之所以使用w寄存器，是因为int为4字节，这也就是类型转换时带来信息丢失的原因，例如从long到int的转换就类似于将x寄存器的值以w的形式进行存储。最后的代码为将栈还原，并返回到函数调用处继续向下执行。

```
add	sp, sp, #16
ret
```
显然，经过这样的操作，栈被完全还原到了函数调用以前的样子，需要注意的细节是，栈空间中的内存单元并未被清空，这也就导致下一次使用低地址的栈时，未初始化单元的值是不确定的，这也就是局部变量不初始化值随机的根本原因。



附录
![指令列表01](/images/%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A801.png)
![指令列表02](/images/%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A802.png)



参考出处
<http://iosre.com/t/topic/8179>
<https://zhuanlan.zhihu.com/c_142064221>
<https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/>
<http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/>



